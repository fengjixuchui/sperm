> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/CIqvvKt8kEqqn7RheZ2YdA)

![](https://mmbiz.qpic.cn/mmbiz_gif/p5YHVYUwZib3B6WPiavosZFcyzR8y0A5ibaMM1XX5UqvEuGcOXrv8GnLZWUSOX4lNfm9DicHF1cU8lY2q0rm7icqt0A/640?wx_fmt=gif)

arm 中的溢出和进位, 在记忆一些条件指令操作码进行逆向的的时候可能会出现难以记忆, 本文梳理一下溢出和进位的表现形式, 以便在遇到的时候可以得心应手的去处理。

![](https://mmbiz.qpic.cn/mmbiz_gif/p5YHVYUwZib3B6WPiavosZFcyzR8y0A5ibaMM1XX5UqvEuGcOXrv8GnLZWUSOX4lNfm9DicHF1cU8lY2q0rm7icqt0A/640?wx_fmt=gif)

  

  

  

  

 目录

  

⊙什么是溢出和进位

⊙溢出和进位的关系

⊙ 溢出和进位对有符号数, 无符号的数的关系

⊙ arm 常用操作码部分解析

**什么是溢出和进位**  

进位: 产生进位 (最高位) 的时候, C 标志位会置为 1

哪些操作会改变 C 标志位呢？

当进行加法运算 (包括 CMN 指令)，并且最高位产生进位时 C=1，否则 C=0。当进行减法运算 (包括 CMP 指令)，并且最高位产生借位时 C=0，否则 C=1, 对于结合移位操作的非加法 / 减法指令，C 为从最高位最后移出的值。

其它指令 C 通常不变.

溢出: 当进行符号数的加减运算时超出有符号数所表示的范围的时候, V 标志位会置为 1。

**溢出和进位的关系**

**这里的进位, 有两种含义一种是最高位进位 (因) 这种是上文的进位设置 C 标志位为 1(果), 另一种进位是数学上的进位也就是, 不是最高位进位其他的位进位, 不会导致 C 标志位设置。**

溢出表现在有符号位的加减运算中, 我们假设存在一种计算机类型存储的数据表示长度为 4 位

那么有符号位的数据表示范围为 - 2^3~2^3-1, 也就是范围为 - 8 到 7

那么什么算溢出呢？感受一下

-4-5

-4  原码为: 1100 补码为: 1011+1= [1100]

-5  原码为: 1101  补码为 :1010+1=[1011]

-4-5 = -9, 实际上超出了表示范围, 那么就溢出了。

[0101]+[0011] = [1000] 转为原码为 1000 其中最高位为符号位, 那么结果为 0

从另一个角度来说 负数最小为 - 8 不存在 - 9 这个数，出现这个情况, 说明就溢出了！

问题来了什么情况下会溢出呢？

声明: 以下数据中 [] 表示为补码！

[0] = [0000]

[-1] = [1111]

[-2] = [1110]

[-3]=  [1101]

[-4]=  [1100]

[-5]=  [1011]

[-6]=  [1010]

[-7]=  [1001]

-2-3 = [1110] + [1101] = [1011]，

符号位 (最高位) 进位, 高位数据位 (次高位) 进位, 没有溢出。

-4-5=[1100] +[1011] =[0111]

符号位 (最高位) 进位, 高位数据位 (次高位) 未进位, 溢出。

6+5 = 0110 +0101=1011

符号位 (最高位) 未进位, 高位数据位 (次高位) 进位, 溢出。

1+2 = 0001+0010 =0011

符号位 (最高位) 未进位, 高数据位 (次高位) 未进位, 没有溢出。

也就是说进位, 不一定会产生溢出, 溢出的情况下在进行加减运算的过程中, 转化为补码当存在符号位和次高位同时为进位或同时不进位的时候, 才不会溢出。

溢出和进位和有符号数, 无符号的数的关系

溢出时的 V 标志位的存在意义为有符号数准备的, 因为有符号数才存在相加或者相减造成越界。  

进位的 C 标志位的存在意义是为了无符号数准备的, 无符号数的最高位在加法的时产生进位或减法的时候最高位不产生借位的时候才会被设置。  

在 arm 汇编底层进行运算的时候 cpu 其实不知道参与运算的是有符号数或无符号数, 还是需要一条指令执行完可以同时会对 C 标志位和 V 标志位进行设置，在后续的代码指令中, 就需要我们编程者人为的处理 (你认为是无符号位就拿无符号位的方式去处理, 如果你认为是有符号位就按照有符号位的方式来处理)。  

arm 常用操作码解析

啊这！我一般用 markdown 进行记录, 无奈微信公众号无法直接复制, 不过不耽误我们来学习！

```
| 操作码 | 条件助记符 | 标志 |含义 |
| :------| ------: | :------: | :------: |
| 0000|EQ |Z=1 |相等(Equal) |
| 0001|NE |Z=0 |不相等(Not Equal) |
| 0010| CS/HS|C=1 |无符号数大于或等于(Carry Set) |
| 0011|CC/LO |C=0 |无符号数小于(Carry clear) |
| 0100| MI| N=1| 负数(minux)|
| 0101| PL| N=0| 正数或零(plus)|
| 0110| VS| V=1| 溢出(oVerflow Set)|
| 0111| VC| V=0| 没有溢出(oVerflow clear)|
| 1000 | HI | C=1,Z=0 | 无符号数大于(higner) |
| 1001| LS| C=0,Z=1| 无符号数小于或等于(lower or same)|
| 1010| GE| N=V| 有符号数大于或者等于(greater or Equal)|
| 1011| LT| N!=V| 有符号数小于(Less Than)|
| 1100| GT| Z=O,N=V| 有符号数大于(Greater Than)|
| 1101| LE| Z=1,N!=V| 有符号数小于或等于(Less or Equal）|
| 1110| AL| 任何| 无条件执行|
| 1111| MV| 任何| 从不执行|

```

观察这个表是不是对于无符号比大小在如果只有 C 和 V 标志位的情况下只有 C 有关系, 而对于有符号数只有 C 和 V 标志位的情况下只有 V 有关系。

```
对于无符号数:
subs r1,r2,r3；假设这条语句执行后C =1
那么 r2 - r3肯定是没借位,自然而然结果r2-r3大于或者等于0
subs r1,r2,r3；假设这条语句执行后C =1,Z=0
相比上方的又加了和Z=0的条件证明,r2-r3肯定就不是0，那么r2大于r3了
有符号数自行类比

```

我是 BestToYou, 分享工作或日常学习中关于二进制逆向和分析的一些思路和一些自己闲暇时刻调试的一些程序, 文中若有错误的地方, 恳请大家联系我批评指正。  

![](https://mmbiz.qpic.cn/mmbiz_gif/p5YHVYUwZib3B6WPiavosZFcyzR8y0A5ibalicqxrfTvYLw2zBMWqnyUFTG4vtoJpcjmckN4BNIusIIr8bU57ucmEA/640?wx_fmt=gif)